# -*- coding: utf-8 -*-
"""[Proyek Predictive Analytics - GBPUSD].ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uv7CarV12eDnPE7EpDLKFTlsyizMztFB

## Proyek Predictive Analysis

Nama = Muh Rivandy Setiawan <br>
Email = muhrivandysetiawan@gmail.com <br>
No Hp = 087888511474 <br>
Instagram = muhrivandy77 <br>

## Pengumpulan dan Pengecekan Data

Data yang disajikan adalah data Pertukaran Birtish Pound Sterling dengan US Dollar dari 1 Januari 2014 sampai 16 Oktober 2024- saya bisa upgrade lagi jika diperlukan selama sebulan. Saya sebagai ML Engineering akan memberikan penjelasan dari code ini.
"""

# Commented out IPython magic to ensure Python compatibility.
# Import the Library
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
# %matplotlib inline
import seaborn as sns

"""Dataset yang diambil tersedia link dibawah ini! <br>
https://www.investing.com/currencies/gbp-usd-historical-data

"""

# Load the Dataset
gbpusd = pd.read_csv("GBP_USD Historical Data.csv")
# Show the Data
gbpusd

"""Karena isi volumenya tidak ada dan terdapat NaN, maka perlu dihapus dan hanya menyediakan nilai yang tersedia saja."""

# Assuming 'Vol.' is the column name you want to drop
gbpusd = gbpusd.drop('Vol.', axis=1)

# Show the updated DataFrame
gbpusd

"""Pada tabel di atas tersedia 7 kolom yang terdiri dari:
1. Date = Tanggal yang dicatat dalam per hari
2. Price = Harga penutupan British Pound Sterling  dalam satu hari perdagangan.
3. Open = Harga pembukaan British Pound Sterling dalam satu hari perdagangan.
4. High = Harga tertinggi British Pound Sterling dalam satu hari perdagangan.
5. Low = Harga terendah British Pound Sterling dalam satu hari perdagangan.
6. Change % = Persentase perubahan harga British Pound Sterling dalam satu hari

Data ini disajikan dari sekarang sampai 10 tahun yang lalu.
"""

# Give the GBPUSD Info
gbpusd.info()

# Checking GBPUSD Duplicated
gbpusd[gbpusd.duplicated()]

"""Ini adalah deskripsi dari British Pound Sterling ke dalam US Dollar.  """

# Describe GBPUSD
gbpusd.describe()

# Checking Volume GBPUSD = 0
gbpusd[gbpusd['Change %'] == 0]

"""Data ini telah bersih dan tidak perlu dibersihkan lagi dengan mengatasi missing value sebab hanya 10 tahun terakhir data ini digunakan. Sebelum itu, tipe datanya dikonversi terlebih dahulu

Data tanggalnya diubah menjadi tipe data tanggal terlebih dahulu agar bisa memprediksi harga British Pound Sterling.
"""

# Change 'Date' column become datetime type
gbpusd['Date'] = pd.to_datetime(gbpusd['Date'])

"""Setelah itu, Harga dan perubahan harga dikonversi dan angka koma dan persen digantikan."""

# Delete comma symbol and conversion column to numeric type (Price, Open, High, Low)
cols_to_convert = ['Price', 'Open', 'High', 'Low', 'Change %']
for col in cols_to_convert:
    # Delete comma symbol and percent, then conversion to float
    if col == 'Change %':
        # Convert the column to string type before using .str accessor
        gbpusd[col] = gbpusd[col].astype(str).str.replace('%', '').astype(float)
    else:
        # Ensure the column is of string type before applying .str methods
        gbpusd[col] = gbpusd[col].astype(str).str.replace(',', '').astype(float)

"""Cek kembali Kolom Data dan Harga British Pound Sterling apakah tipe datanya sesuai yang diinginkan."""

# Show information dataset after conversion
print(gbpusd.info())

"""Sekarang data yang dibutuhkan bisa diukur ke boxplot. Boxplot mengidentifikasi outlier (nilai pencilan) dalam data."""

# Creates a box plot of GBPUSD prices.
sns.boxplot(x=gbpusd['Price'])

# Creates a box plot of GBPUSD Open.
sns.boxplot(x=gbpusd['Open'])

# Creates a box plot of GBPUSD High.
sns.boxplot(x=gbpusd['High'])

# Creates a box plot of GBPUSD Low.
sns.boxplot(x=gbpusd['Low'])

# Creates a box plot of GBPUSD Change in %.
sns.boxplot(x=gbpusd['Change %'], showfliers=False)

"""## Univariat Analysis

Tipe datanya telah diubah menjadi tipe data yang diinginkan. Pengubahan tipe data ini ditujukan agar bisa melakukan sebuah forecast dalam harga pasar British Pound Sterling
"""

# Create fucntion for univariate analysis
def univariate_analysis(column):
    # Plot column distribution
    plt.figure(figsize=(10, 6))
    sns.histplot(gbpusd[column], bins=30, kde=True)
    plt.title(f'Distribusi {column}')
    plt.xlabel(column)
    plt.ylabel('Frekuensi')
    plt.show()

# Univariate analysis for column 'Price'
univariate_analysis('Price')

# Univariate analysis for column 'Price'
univariate_analysis('Open')

# Univariate analysis for column 'Price'
univariate_analysis('High')

# Univariate analysis for column 'Price'
univariate_analysis('Low')

# Univariate analysis for another column
univariate_analysis('Change %')

"""Pada data dan chart di atas merupakan analisis univariat yang terdiri dari:
 1. count (jumlah data);
 2. rata-rata,
 3. standar deviasi;
 4. minimal angka;
 5. Q1;
 6. Median;
 7. Q3;
 8. maksimal.

 Tidak ada nilai null dan duplikat. Lalu dalam frekuensi itu adalah jumlah berapa banyak data itu.

Frekuensi dalam analisis univariat menunjukkan seberapa sering suatu nilai atau kategori muncul dalam suatu variabel.
"""

# Price Bitcoin from 2014 to 2024
plt.figure(figsize=(18, 6))
plt.plot(gbpusd['Date'], gbpusd['Price'])
plt.title('Perkembangan GBP/USD')
plt.xlabel('Tanggal')
plt.ylabel('Harga (USD)')
plt.grid(True)
plt.show()

"""Ini adalah Harga British Pound Sterling yang ditarik dari 2014 sampai sekarang!"""

# Change % Bitcoin in from 2014 to 2024
plt.figure(figsize=(18, 6))
plt.plot(gbpusd['Date'], gbpusd['Change %'])
plt.title('Perkembangan Perubahan gbpusd')
plt.xlabel('Tanggal')
plt.ylabel('Perubahan')
plt.grid(True)
plt.show()

"""## Multivariat Analysis

Ini adalah chart persentase perubahan Harga Pound Sterling yang dihitung perhari. Bisa positif dan bisa negatif
"""

# Multivariate Analysis Bitcoin from 2014 to 2024
plt.figure(figsize=(12, 6))
plt.plot(gbpusd['Date'], gbpusd['Open'], label='Open')
plt.plot(gbpusd['Date'], gbpusd['Price'], label='Price')
plt.plot(gbpusd['Date'], gbpusd['High'], label='High')
plt.plot(gbpusd['Date'], gbpusd['Low'], label='Low')
plt.title('Perkembangan GBPUSD (Open, Price, High, Low)')
plt.xlabel('Tanggal')
plt.ylabel('Harga (USD)')
plt.grid(True)
plt.legend()
plt.show()

"""Disini diperlihatkan chart Bitcoin sudah termasuk open, price (close), high, dan low.

Terdapat 2 analisis multivariat yang bisa dianalisis, yakni Pairpolot dan Correlation Matrix. Pairplot Memvisualisasikan hubungan antara setiap pasangan variabel dalam dataset.Sedangkan, Correlation Matrix Menghitung dan menampilkan korelasi antar variabel dalam dataset.
"""

# Relationship numerik feature with pairplot() function
sns.pairplot(gbpusd, diag_kind = 'kde')

# Correlation matrix
correlation_matrix = gbpusd.corr()

# Plotting heatmap for correlation
plt.figure(figsize=(12, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', linewidths=0.5)
plt.title('Correlation Matrix Heatmap')
plt.show()

"""## Data Preparation
Sekarang, analisis persiapan data dengan menggunakan PCA untuk mereduksi dimensi data dengan tetap mempertahankan sebanyak mungkin informasi penting dari data asli.
"""

# reduksi Dimensi
# Import required libraries
import pandas as pd
from sklearn.decomposition import PCA

# Select the columns for PCA
columns_for_pca = ['Open', "High", "Low"]

# Perform PCA
# Change n_components to be less than or equal to the number of features (3 in this case)
pca = PCA(n_components=1, random_state=123)
pca.fit(gbpusd[columns_for_pca])

# Transform the data
principal_components = pca.transform(gbpusd[columns_for_pca])

# If you want to create a new DataFrame with the principal components
# Adjust the number of columns to match n_components
pca_df = pd.DataFrame(
    data=principal_components,
    columns=['PC1']
)

# You can then add this to your original DataFrame if needed
gbpusd_with_pca = pd.concat([gbpusd, pca_df], axis=1)

# Print out the explained variance ratio
print("Explained Variance Ratio:", pca.explained_variance_ratio_.round(1))

gbpusd_with_pca

"""## Train-Test Split Data

Sekarang Data Train dan Test akan dibagi dalam skala 80:20. Data yang diambil untuk training kali ini adalah Price dan Date
"""

# DataFrame GBP/USD after PCA
gbpusd = gbpusd_with_pca

# Take value that needed
price = gbpusd["Price"].values
dates = gbpusd["Date"].values

# Make a Split Ratio
split_ratio = 0.8
split_point = int(len(gbpusd) * split_ratio)

# Create training and testing DataFrames
X_train = price[:split_point]
X_test = price[split_point:]

# Split Dates become train and test
dates_train = dates[:split_point]
dates_test = dates[:split_point]

# Change dimension X_train and X_test become 2D
X_train = X_train.reshape(-1, 1)
X_test = X_test.reshape(-1, 1)

"""Setelah itu, lakukan MinMaxScaler untuk menskalakan data ke rentang tertentu, biasanya antara 0 dan 1. Ini membantu meningkatkan kinerja model machine learning."""

# Import MinMaxScaler
from sklearn.preprocessing import MinMaxScaler

# Choose feature which can standardisation
scaler = MinMaxScaler(feature_range=(0,1))
scaler.fit(X_train)

# Transform data training and testing
X_train = scaler.transform(X_train)
X_test = scaler.transform(X_test)

"""## Window Datasets

Window Dataset berfungsi untuk mengubah data deret waktu (time series) menjadi bentuk yang cocok untuk model machine learning.

Cara kerjanya Data dibagi menjadi beberapa jendela (windows) dengan ukuran tertentu. Setiap jendela berisi data historis (input) dan nilai target (output) yang ingin diprediksi. Jendela-jendela ini kemudian digunakan untuk melatih model.
"""

# Import Tensorflow for Window Dataset
import tensorflow as tf

# Define the Window Dataset
def windowed_dataset(series, window_size, batch_size, shuffle_buffer):
    ds = tf.data.Dataset.from_tensor_slices(series)
    ds = ds.window(window_size+1, shift=1, drop_remainder=True)
    ds = ds.flat_map(lambda w: w.batch(window_size+1))
    ds = ds.map(lambda window: (window[:-1], window[-1]))
    ds = ds.shuffle(shuffle_buffer)
    ds = ds.batch(batch_size).prefetch(1)
    return ds

# Make a Window Size, Batch Size, and Shuffle Buffer
window_size = 10
batch_size = 32
shuffle_buffer = len(gbpusd)

# Window the price_data
train_set = windowed_dataset(X_train, window_size, batch_size, shuffle_buffer)
test_set = windowed_dataset(X_test, window_size, batch_size, shuffle_buffer)

"""## Modelling (LSTM)"""

# Import Library for LSTM
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout

# Build LSTM model
model = Sequential() # This line is added to define the model as a Sequential object
model.add(LSTM(units = 64, return_sequences = True, input_shape = [None, 1], activation='tanh'))
model.add(Dropout(0.1))  # Reduced dropout
model.add(LSTM(100, activation='tanh'))  # Increased units
model.add(Dropout(0.1))  # Reduced dropout
model.add(Dense(50, activation='tanh'))  # New Dense layer
model.add(Dense(1))

# Compile the model
optimizer = tf.keras.optimizers.SGD(momentum=0.9)
model.compile(
    loss=tf.keras.losses.Huber(),
    optimizer=tf.keras.optimizers.Adam(),
    metrics=["mae"]
)

# Summary the model
model.summary()

# Train the Model
history = model.fit(train_set, epochs=200, validation_data=test_set)

"""## Evaluate Result"""

# Plot training loss
plt.plot(history.history['loss'], label='Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.title('Model Loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()
plt.show()

# Plot MAE
plt.plot(history.history['mae'], label='MAE')
plt.plot(history.history['val_mae'], label='Validation MAE')
plt.title('Model MAE')
plt.xlabel('Epochs')
plt.ylabel('MAE')
plt.legend()
plt.show()

# Print the shape of X_test before reshaping
print("Shape of X_test before reshaping:", X_test.shape)

# Reshape X_test if model needed
x_testReshape = np.reshape(X_test, (X_test.shape[0], X_test.shape[1], 1))

# Print the shape of X_test after reshaping
print("Shape of X_test after reshaping:", x_testReshape.shape)

# Make the predictions
predictions = model.predict(x_testReshape)

# Inversion normalization if needed
predictions = scaler.inverse_transform(predictions)

# Show the Prediction
predictions

# Show real x_train dan x_valid
x_train_original = scaler.inverse_transform(X_train.reshape(-1, 1))
x_test_original = scaler.inverse_transform(X_test.reshape(-1, 1))

# Plot actual vs predicted prices for the test set
plt.figure(figsize=(12, 6))
plt.plot(x_test_original, label='Actual Prices', color='blue')
plt.plot(predictions, label='Predicted Prices', color='red', alpha=0.7)
plt.title('Actual vs Predicted GBPUSD', fontsize=16)
plt.xlabel('Time', fontsize=12)
plt.ylabel('Price (USD)', fontsize=12)
plt.legend(fontsize=12)
plt.grid(True)  # Add grid for better readability
plt.show()

"""Kode tersebut memplot perbandingan harga aktual (biru) dan harga prediksi (merah) GBPUSD. Plot ini menggunakan data x_test_original untuk harga aktual dan predictions untuk harga prediksi, dengan label dan judul yang jelas. Grid ditambahkan untuk memudahkan pembacaan.

Print Evaluasi MAE
"""

# Show to MAE Result
print("MAE Result:", history.history['mae'][-1])